{"version":1,"windowDimensions":{"x":0,"y":0,"width":1440,"height":873,"maximized":false},"grammars":{"grammarOverridesByPath":{}},"project":{"deserializer":"Project","paths":["/Users/vmaudgalya/Downloads/homework1"],"buffers":[{"id":"f04f80680f4adfec4e45b9f24ee26df2","text":"","defaultMarkerLayerId":"0","markerLayers":{"0":{"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"id":"2","maintainHistory":true,"markersById":{"1":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection"},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","preferredLineEnding":"\n","nextMarkerId":2,"deserializer":"TextBuffer","version":5},{"id":"ce5471c89289b095f11535d989468137","text":"'''\n * Copyright (c) 2014, 2015 Entertainment Intelligence Lab, Georgia Institute of Technology.\n * Originally developed by Mark Riedl.\n * Last edited by Mark Riedl 05/2015\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n'''\n\nimport sys, pygame, math, numpy, random, time, copy\nfrom pygame.locals import * \n\nfrom constants import *\nfrom utils import *\nfrom core import *\nfrom gridnavigator import *\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\nnav = GreedyGridNavigator()\n\t\t\t\n\t\t\t\nworld = GameWorld(SEED, WORLD, SCREEN)\nagent = Agent(AGENT, (SCREEN[0]/2, SCREEN[1]/2), 0, SPEED, world)\nworld.initializeTerrain([[(628, 698), (582, 717), (549, 688), (554, 546), (676, 548)], [(942, 484), (811, 396), (843, 299), (921, 300)], [(457, 422), (371, 506), (300, 515), (300, 400), (454, 350)]], (0, 0, 0), 4, TREE) \nworld.setPlayerAgent(agent)\nagent.setNavigator(nav)\nnav.setWorld(world)\nworld.initializeRandomResources(NUMRESOURCES)\nworld.debugging = True\nworld.run()\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"id":"2","maintainHistory":true,"markersById":{"1":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection"},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/vmaudgalya/Downloads/homework1/rungreedygridnavigator1.py","digestWhenLastPersisted":"1ed4a04636054424a48b6cb02869a1ea4addb8d5","preferredLineEnding":null,"nextMarkerId":2,"deserializer":"TextBuffer","version":5},{"id":"dab4e908e53706e97c304da1f863729b","text":"'''\n * Copyright (c) 2014, 2015 Entertainment Intelligence Lab, Georgia Institute of Technology.\n * Originally developed by Mark Riedl.\n * Last edited by Mark Riedl 05/2015\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n'''\n\nSCREEN = [1024, 768]\nWORLD = [1024, 768]\nTICK = 60\n\nSPEED = (5, 5)\nNUMOBSTACLES = 3\nOBSTACLERADIUS = 200\nOBSTACLESIGMA = 50\nOBSTACLEMIN = 25\nOBSTACLEPOINTS = 7\nOBSTACLEGRIDSIZE = 50\nNUMRESOURCES = 20\nSEED = 2\nHITPOINTS = 25\nBASEHITPOINTS = 75\nTOWERHITPOINTS = 50\n\n\nAGENT = \"sprites/spartan2.gif\"\nSMALLBULLET = \"sprites/bullet.gif\"\nBIGBULLET = \"sprites/bullet2.gif\"\nRESOURCE = \"sprites/crystal.gif\"\nGATE = \"sprites/mine.gif\"\nNPC = \"sprites/spartan.gif\"\nJACKAL = \"sprites/jackal.gif\"\nELITE = \"sprites/elite.gif\"\nCRATE = \"sprites/crate.gif\"\nBASE = \"sprites/base.gif\"\nCRYSTAL = \"sprites/crystal.gif\"\nTREE = \"sprites/tree.gif\"\nMINE = \"sprites/mine.gif\"\nTOWER = \"sprites/tower.gif\"\n\n\nSMALLBULLETSPEED = (20, 20)\nSMALLBULLETDAMAGE = 1\nBIGBULLETSPEED = (20, 20)\nBIGBULLETDAMAGE = 5\nFIRERATE = 10\nDODGERATE = 10\n\nINFINITY = float(\"inf\")\n\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"id":"2","maintainHistory":true,"markersById":{"1":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection"},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/vmaudgalya/Downloads/homework1/constants.py","digestWhenLastPersisted":"2ff6cd580c41f799e1ab1254bd6ee753d8572c9d","preferredLineEnding":null,"nextMarkerId":2,"deserializer":"TextBuffer","version":5},{"id":"3192ff0ad127b6ed59987222b98e8653","text":"'''\n * Copyright (c) 2014, 2015 Entertainment Intelligence Lab, Georgia Institute of Technology.\n * Originally developed by Mark Riedl.\n * Last edited by Mark Riedl 05/2015\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n'''\n\nimport sys, pygame, math, numpy, random, time, copy\nfrom pygame.locals import * \n\nfrom constants import *\nfrom utils import *\n\n\n###########################\n\ncorerandom = random.Random()\n\n\n  \n###########################\n### Thing\n\nclass Thing(object):\n\n\tdef update(self, delta):\n\t\treturn None\n\t\t\n\tdef collision(self, thing):\n\t\treturn None\n\t\t\n#\tdef notify(self):\n#\t\treturn None\n  \n\n###########################\n### Mover\n\nclass Mover(pygame.sprite.Sprite, Thing):\n\n\t\t\n\t### rect: the rectangle\n\t### image: the image, rotated to orientation\n\t### originalImage: the image un-rotated\n\t### orientation: direction agent is facing in degrees (0 = to the right)\n\t### speed: how fast the agent moves (horizontal, vertical)\n\t### radius: the bounding circle (max(width, height))\n\t### world: the world\n\t### owner: the thing that created me\n\t### alive: the agent is alive (boolean)\n\t\n\tdef __init__(self, image, position, orientation, speed, world):\n\t\tpygame.sprite.Sprite.__init__(self) # call sprite initializer\n\t\tself.image, self.rect = load_image(image, -1)\n\t\tself.originalImage = self.image.copy()\n\t\tself.orientation = orientation\n\t\tself.world = world\n\t\tself.speed = speed \n\t\tself.radius = distance(self.rect.topleft, self.rect.bottomright)/2.0 #max(self.rect.width, self.rect.height)/2.0\n\t\t## Translate to initial position\n\t\tself.rect = self.rect.move(position)\n\t\tself.turnToAngle(orientation)\n\t\tself.owner = None\n\t\tself.alive = True\n\t\t\n\tdef getRadius(self):\n\t\treturn self.radius\n\t\t\n\t\n\t### Tells the agent to face a point\n\tdef turnToFace(self, pos):\n#\t\tdirection = [m - n for m,n in zip(pos,self.rect.center)]\n\t\tdirection = (pos[0] - self.getLocation()[0], pos[1] - self.getLocation()[1])\n\t\tangle = math.degrees(numpy.arctan2(direction[0],direction[1]))-90\n\t\tself.turnToAngle(angle)\n\t\t\n\t### Tells the agent which way to face\n\tdef turnToAngle(self, angle):\n\t\tif angle < 0:\n\t\t\t#unwind\n\t\t\tangle = 360+angle\n\t\tself.orientation = angle\n\t\trot_img = pygame.transform.rotate(self.originalImage, self.orientation)\n\t\timg_rect = rot_img.get_rect()\n\t\timg_rect.center = self.rect.center\n\t\tself.image = rot_img\n\t\tself.rect = img_rect\n\t\n\t### Update the agent every tick. Primarily does movement\n\tdef update(self, delta):\n\t\tThing.update(self, delta)\n\t\treturn None\n\t\t\n\t### When something collides with me\n\tdef collision(self, thing):\n\t\tThing.collision(self, thing)\n#\t\tprint \"collision\", self, thing\n\t\treturn None\n\t\t\n\t# Get the object's (x, y) location\n\tdef getLocation(self):\n\t\treturn self.rect.center\n\t\t\n\tdef getOrientation(self):\n\t\treturn self.orientation\n\t\t\n\tdef getOwner(self):\n\t\treturn self.owner\n\t\t\n\tdef setOwner(self, owner):\n\t\tself.owner = owner\n\n\tdef isAlive(self):\n\t\treturn self.alive\n\n\tdef die(self):\n\t\tself.alive = False\n\t\t\n############################\n### RESOURCE\n\nclass Resource(Mover):\n\n\tdef __init__(self, image, position, orientation, world):\n\t\tMover.__init__(self, image, position, orientation, (0, 0), world)\n\n\n\t\t\t\n###########################\n### SimpleResource\n\nclass SimpleResource(Resource):\n\n\tdef __init__(self, image, position, orientation, world):\n\t\tResource.__init__(self, image, position, orientation, world)\n\n\tdef collision(self, thing):\n\t\tResource.collision(self, thing)\n\t\tif isinstance(thing, Agent):\n\t\t\tprint \"grabbed\"\n\t\t\tself.world.deleteResource(self)\n\n\n###########################\n### BULLET\n\nclass Bullet(Mover):\n\t\n\t### damage: amount of damage\n\t### distanceTraveled: the total amount of distance traveled by the agent\n\n\n\tdef __init__(self, position, orientation, world, image = SMALLBULLET, speed = SMALLBULLETSPEED, damage = SMALLBULLETDAMAGE):\n\t\tMover.__init__(self, image, position, orientation, speed, world)\n\t\tself.damage = damage\n\t\tself.distanceTraveled = 0\n\t\t\n\tdef getDamage(self):\n\t\treturn self.damage\n\t\t\n\t### Update the agent every tick. Primarily does movement\n\tdef update(self, delta):\n\t\tMover.update(self, delta)\n\t\tunwound = self.orientation\n\t\tif unwound < 0:\n\t\t\tunwound = unwound + 360.0\n\t\trad = math.radians(unwound)\n\t\tnormalizedDirection = (math.cos(rad), -math.sin(rad))\n\t\tnext = [m*n for m,n in zip(normalizedDirection,self.speed)]\n\t\tself.distanceTraveled = self.distanceTraveled + distance((0,0), next)\n\t\tself.rect = self.rect.move(next)\n\t\treturn None\n\n\tdef collision(self, thing):\n\t\tMover.collision(self, thing)\n\t\tif self.hit(thing):\n\t\t\tself.speed = (0, 0)\n\t\t\tself.world.deleteBullet(self)\n\n\t### Hit verifies that it has hit something hitable and what it should do (e.g., cause damage) \n\tdef hit(self, thing):\n\t\tif thing != self.owner and isinstance(thing, Agent) and (thing.getTeam() == None or thing.getTeam() != self.owner.getTeam()):\n\t\t\tthing.damage(self.damage)\n\t\t\treturn True\n\t\telif isinstance(thing, Obstacle) or isinstance(thing, Gate) or self.rect.center[0] < 0 or self.rect.center[0] > self.world.dimensions[0] or self.rect.center[1] < 0 or self.rect.center[1] > self.world.dimensions[1]:\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\n\n\t\t\t\t\n\t\t\t\t\n\n\n###########################\n### AGENT\n\nclass Agent(Mover):\n\n\t### moveTarget: where to move to. Setting this to non-None value activates movement (update fn)\n\t### moveOrigin: where moving from.\n\t### navigator: model that does pathplanning\n\t### firerate: how often agent can fire\n\t### firetimer: how long since last firing\n\t### canfire: can the agent fire?\n\t### hitpoints: amount of damage the agent can take\n\t### team: symbol referring to the team (or None)\n\t### distanceTraveled: the total amount of distance traveled by the agent\n\n\t### Constructor\n\tdef __init__(self, image, position, orientation, speed, world, hitpoints = HITPOINTS, firerate = FIRERATE, bulletclass = Bullet):\n\t\tMover.__init__(self, image, position, orientation, speed, world) \n\t\tself.moveTarget = None\n\t\tself.moveOrigin = None\n\t\tself.navigator = None\n#\t\tself.bulletspeed = bulletspeed\n\t\tself.firerate = firerate\n\t\tself.firetimer = 0\n\t\tself.canfire = True\n\t\tself.bulletclass = bulletclass\n\t\tself.hitpoints = hitpoints\n\t\tself.team = None\n\t\tself.distanceTraveled = 0\n\n\n\t### Update the agent every tick. Primarily does movement\n\tdef update(self, delta):\n\t\tMover.update(self, delta)\n\t\tif self.moveTarget is not None:\n\t\t\tdrawCross(self.world.background, self.moveTarget, (0, 0, 0), 5)\n\t\t\tdirection = [m - n for m,n in zip(self.moveTarget,self.rect.center)]\n\t\t\t# Figure out distance to moveTarget\n#\t\t\tmag = reduce(lambda x, y: (x**2)+(y**2), direction)**0.5 \n\t\t\tmag = distance(self.getLocation(), self.moveTarget)\n\t\t\tif mag < self.getRadius()/2.0: #min(self.rect.width,self.rect.height)/2.0:\n\t\t\t\t# Close enough\n\t\t\t\tself.moveTarget = None\n\t\t\t\tself.moveOrigin = None\n\t\t\t\tif self.navigator != None:\n\t\t\t\t\tself.navigator.doneMoving()\n\t\t\t\t\tself.doneMoving()\n\t\t\telse:\n\t\t\t\t# Move\n\t\t\t\tnormalizedDirection = [x/mag for x in direction]\n\t\t\t\tnext = [m*n for m,n in zip(normalizedDirection,self.speed)]\n\t\t\t\tself.distanceTraveled = self.distanceTraveled + distance((0,0), next)\n\t\t\t\tself.rect = self.rect.move(next)\n\t\t\t\tself.navigator.update(delta)\n\t\t\t\t# Check for shortcut\n\t\t\t\tif self.navigator != None:\n\t\t\t\t\tself.navigator.smooth()\n\t\tif self.canfire == False:\n\t\t\tself.firetimer = self.firetimer + 1\n\t\t\tif self.firetimer >= self.firerate:\n\t\t\t\tself.canfire = True\n\t\t\t\tself.firetimer = 0\n\t\treturn None\n\t\t\n\tdef doneMoving(self):\n\t\treturn None\n\t\t\n\t### NOTE: problem: Agent can be subclassed and collision() can be overridden such that the agent is not stopped by obstacles/blockers\n\tdef collision(self, thing):\n\t\tMover.collision(self, thing)\n\t\tif self.moveTarget is not None:\n\t\t\tif isinstance(thing, Blocker):\n\t\t\t\t# Ran into something that I can't move through\n\t\t\t\tself.moveTarget = None\n\t\t\t\tself.moveOrigin = None\n\t\t\t\tif self.navigator != None:\n\t\t\t\t\tself.navigator.collision(thing)\n\t\treturn None\n\t\t\n\t\t\t\n\t### MoveToTarget tells the agent where to go and starts movement\n\tdef moveToTarget(self, pos):\n\t\tself.moveTarget = pos\n\t\tself.moveOrigin = self.rect.center\n\t\tself.turnToFace(pos)\n\t\n\n\t### Set the pathplanning module\n\tdef setNavigator(self, navigator):\n\t\tnavigator.setAgent(self)\n\t\tself.navigator = navigator\n\n\tdef navigateTo(self, pos):\n\t\tif self.navigator != None:\n\t\t\tself.navigator.computePath(self.rect.center, pos)\n\n\t### Shoot the gun. Return the bullet that was spawned, or None.\n\tdef shoot(self):\n\t\tif self.canfire:\n\t\t\tbullet = self.bulletclass(self.rect.center, self.orientation, self.world)\n\t\t\tbullet.setOwner(self)\n\t\t\tself.world.addBullet(bullet)\n\t\t\tself.canfire = False\n\t\t\treturn bullet\n\t\telse:\n\t\t\treturn None\n\t\t\t\n\tdef setTeam(self, team):\n\t\tself.team = team\n\t\t\n\tdef getTeam(self):\n\t\treturn self.team\n\t\t\n\tdef damage(self, amount):\n\t\tself.hitpoints = self.hitpoints - amount\n\t\t### Something should happen when hitpoints are <= 0\n\t\tif self.hitpoints < 0:\n\t\t\tself.die()\n\n\tdef die(self):\n\t\tMover.die(self)\n\t\tself.stop()\n\t\tself.world.deleteNPC(self)\n\t\t\n\tdef start(self):\n\t\treturn None\n\t\t\n\tdef stop(self):\n\t\tself.stopMoving()\n\t\t\n\tdef stopMoving(self):\n\t\tself.moveTarget = None\n\t\t\n\tdef isMoving(self):\n\t\tif self.moveTarget is not None:\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\n\t\t\n\tdef getMoveTarget(self):\n\t\treturn self.moveTarget\n\n\tdef getHitpoints(self):\n\t\treturn self.hitpoints\n\n\tdef canFire(self):\n\t\treturn self.canfire \n\n\t\t\t\t\t\t\t\n#####################\n### GhostAgent\n### \n### Doesn't collide with anything. This is handled by overriding the collision function, which is generally a bad idea.\n\nclass GhostAgent(Agent):\n\n\tdef collision(self, thing):\n\t\treturn None\n\t\t\n\t\t\n\n#####################\n### Gatherer\n###\n### Takes a list of target resources and gathers them one at a time.\n### Will simply gather them in the order given.\n\nclass Gatherer(Agent):\n\n\t### targets: resources to be gathered\n\t### score: the number of resources gathered\n\n\t### Constructor\n\tdef __init__(self, image, position, orientation, speed, world, hitpoints = HITPOINTS, firerate = FIRERATE, bulletclass = Bullet):\n\t\tAgent.__init__(self, image, position, orientation, speed, world, hitpoints, firerate, bulletclass) \n\t\tself.targets = []\n\t\tself.score = 0\n\t\n\tdef setTargets(self, targets):\n\t\tself.targets = targets\n\t\n\tdef addTarget(self, target):\n\t\tself.targets.append(target)\n\t\t\n\tdef addToScore(self, points):\n\t\tself.score = self.score + points\n\t\tprint \"score\", self.score\n\n\n\tdef setNavigator(self, navigator):\n\t\t# Call the parent class, setting the navigator\n\t\tAgent.setNavigator(self, navigator)\n\n\t\t\n\tdef doneMoving(self):\n\t\tif len(self.targets) > 0:\n\t\t\tcurrent = self.targets[0]\n\t\t\tif distance(self.rect.center, current) < self.radius/2.0:\n\t\t\t\t# close enough, go to the next target\n\t\t\t\tself.targets.pop(0)\n\t\t\t\tif len(self.targets) > 0:\n\t\t\t\t\tself.navigateTo(self.targets[0])\n\n\tdef start(self):\n\t\tAgent.start(self)\n\t\tif self.navigator != None and len(self.targets) > 0:\n\t\t\tself.navigateTo(self.targets[0])\n\t\t\t\n\tdef collision(self, thing):\n\t\tAgent.collision(self, thing)\n#\t\tprint \"gatherer collision\"\n\t\tif isinstance(thing, Resource):\n\t\t\tself.addToScore(1)\n\n\n\n#####################\n### Navigator\n\nclass Navigator():\n\t\n\t### Path: the planned path of nodes\n\t### World: a pointer to the world object\n\t### Agent: the agent doing the navigation\n\t### source: where starting from\n\t### destination: where trying to go\n\t\n\t\n\tdef __init__(self):\n\t\tself.path = None\n\t\tself.world = None\n\t\tself.agent = None\n\t\tself.source = None\n\t\tself.destination = None\n\n\t\n\tdef setAgent(self, agent):\n\t\tself.agent = agent\n\t\n\tdef setPath(self, path):\n\t\tself.path = path\n\n\tdef getSource(self):\n\t\treturn self.source\n\t\n\tdef getDestination(self):\n\t\treturn self.destination\n\t\n\tdef getPath(self):\n\t\treturn self.path\n\n\t### Set the world object\n\t### self: the navigator object\n\t### world: the world object\n\tdef setWorld(self, world):\n\t\t# Store the world object\n\t\tself.world = world\n\t\n\t\n\t### Callback from Agent. Agent has reached its move target and must determine what to do next.\n\t### If the path has been exhausted, the agent moves directly to the destination. Otherwise, it gets the next waypoint from the path.\n\tdef doneMoving(self):\n\t\t# Check that the agent is valid\n\t\tif self.agent != None:\n\t\t\t# Check that the path is set\n\t\t\tif self.path != None:\n\t\t\t\t# If the path length is 0, then the path has been exhausted and it should be safe to move directly to the destination.\n\t\t\t\tif len(self.path) == 0:\n\t\t\t\t\t# Tell the agent to go to the destination\n\t\t\t\t\tself.agent.moveToTarget(self.destination)\n\t\t\t\t\tself.path = None\n\t\t\t\t\tself.source = None\n\t\t\t\t\tself.destination = None\n\t\t\t\telse:\n\t\t\t\t\t# Get the next waypoint and go there instead\n\t\t\t\t\tnext = self.path.pop(0)\n\t\t\t\t\tself.agent.moveToTarget(next)\n\t\t\t\t\tself.checkpoint()\n\n\t### Called when the agent gets to a node in the path\n\t### self: the navigator object\n\tdef checkpoint(self):\n\t\treturn None\n\t\n\t### Callback from Agent. Agent has collided with something.\n\tdef collision(self, thing):\n\t\tprint \"Collision\"\n\t\n\t### This function gets called by the agent to figure out if some shortcutes can be taken when traversing the path.\n\t### This function should update the path and return True if the path was updated\n\tdef smooth(self):\n\t\treturn False\n\t\n\t### Finds the shortest path from the source to the destination. It should minimally set the path.\n\t### self: the navigator object\n\t### source: the place the agent is starting from (i.e., it's current location)\n\t### dest: the place the agent is told to go to\n\tdef computePath(self, source, dest):\n\t\t# Check that the agent is valid\n\t\tif self.agent != None:\n\t\t\t# Just move straight to destination.\n\t\t\tself.source = source\n\t\t\tself.destination = dest\n\t\t\tself.agent.moveToTarget(dest)\n\n\t### Gets called after every agent.update()\n\t### self: the navigator object\n\t### delta: time passed since last update\n\tdef update(self, delta):\n\t\treturn None\n\n\n#####################\n### PathNetworkNavigator\n###\n### Abstract Navigator class that uses a network of path nodes.\n\nclass PathNetworkNavigator(Navigator):\n\n\t### pathnodes: the path nodes\n\t### pathnetwork: the edges between path nodes\n\n\tdef __init__(self):\n\t\tNavigator.__init__(self)\n\t\tself.pathnodes = None\n\t\tself.pathnetwork = None\n\n\tdef drawPathNetwork(self, surface):\n\t\tif self.pathnetwork is not None:\n\t\t\tfor l in self.pathnetwork:\n\t\t\t\tpygame.draw.line(surface, (0, 0, 255), l[0], l[1], 1)\n\n#####################\n### NavMeshNavigator\n###\n### Abstract Navigator class that assumes the agent is traversing a path network created by a nav mesh.\n\nclass NavMeshNavigator(PathNetworkNavigator):\n\t\n\t### pathnodes: the path nodes\n\t### pathnetwork: the edges between path nodes\n\t### navmesh: the polygons making up the nav mesh\n\t\n\tdef __init__(self):\n\t\tPathNetworkNavigator.__init__(self)\n\t\tself.navmesh = None\n\t\n\t### Set the world object\n\t### self: the navigator object\n\t### world: the world object\n\tdef setWorld(self, world):\n\t\tNavigator.setWorld(self, world)\n\t\t# Create the path network\n\t\tself.createPathNetwork(world)\n\t\t# Draw the world\n\t\tself.drawNavMesh(self.world.debug)\n\t\tself.drawPathNetwork(self.world.debug)\n\t\n\t### Create the pathnode network and pre-compute all shortest paths along the network\n\t### self: the navigator object\n\t### world: the world object\n\tdef createPathNetwork(self, world):\n\t\treturn None\n\n\tdef drawNavMesh(self, surface):\n\t\tif self.navmesh is not None:\n\t\t\tfor p in self.navmesh:\n\t\t\t\tdrawPolygon(p, surface, (0, 255, 0), 1, False)\n\n\n\n#####################\n### Blocker\n###\n### A thing that prevents Agent movement\n### I don't know how to make a class with nothing in it, so I made a dummy constructor\n\nclass Blocker:\n\tpass\n\t\t\n\n#####################\n### Obstacle\n\n\nclass Obstacle(Thing, Blocker):\n\n\t### Note: the points are sorted in order of increasing angle around a central point.\n\n\t### points: points of the polygon relative to center\n\t### pos: center of polygon\n\t### lines: lines of polygon relative to center\n\t### surface: the surface\n\t### rect: the rectangle of the surface\n\t\n\tdef __init__(self):\n\t\tself.points = []\n\t\tself.pos = [0, 0]\n\t\tself.lines = []\n\t\tself.surface = None\n\t\tself.rect = None\n\t\t\n\t### Draw me\n\tdef draw(self, parent):\n\t\tif self.surface != None:\n\t\t\tparent.blit(self.surface, self.pos)\n\t\treturn None\n\t\t\n\t### Returns the lines with the obstacle offset\n\tdef getLines(self):\n\t\t#lines = map(lambda l: ([m + n for m,n in zip(l[0], self.pos)], [m + n for m,n in zip(l[1], self.pos)]), self.lines)\n\t\t#return [tuple(i) for i in lines]\n\t\treturn self.lines\n\n\n\t### Returns the points with the obstacle offset\n\tdef getPoints(self):\n\t\t#points = map(lambda p: [m + n for m,n in zip(p, self.pos)], self.points)\n\t\t#return [tuple(i) for i in points]\n\t\treturn self.points\n\n\t### Is a point one of the obstacle points?\n\tdef isInPoints(self, point):\n\t\treturn point in self.getPoints()\n\t\t\n\tdef twoAdjacentPoints(self, p1, p2):\n\t\tif self.isInPoints(p1) and self.isInPoints(p2):\n\t\t\treturn (abs(self.points.index(p1) - self.points.index(p2)) == 1) or (p1 == self.points[0] and p2 == self.points[len(self.points)-1]) or (p2 == self.points[0] and p1 == self.points[len(self.points)-1])\n\t\telse:\n\t\t\treturn False\n\t\t\t\n\tdef pointInside(self, point):\n\t\treturn pointInsidePolygonLines(point, self.lines)\n\n######################\n### Decoration\n\nclass Decoration(pygame.sprite.Sprite):\n\n\tdef __init__(self, image, position, orientation = 0):\n\t\tpygame.sprite.Sprite.__init__(self) # call sprite initializer\n\t\tself.image, self.rect = load_image(image, -1)\n\t\t## Translate to initial position\n\t\tself.rect = self.rect.move(position)\n\t\trot_img = pygame.transform.rotate(self.image, orientation)\n\t\timg_rect = rot_img.get_rect()\n\t\timg_rect.center = self.rect.center\n\t\tself.image = rot_img\n\t\tself.rect = img_rect\n\t\t\n\n\n#####################\n### RandomObstacle\n###\n### NOTE: Doesn't work with my APSP code\n\n\nclass RandomObstacle(Obstacle):\n\n\tdef __init__(self, num, pos, radius, sigma, min, color = (0, 0, 0), linewidth = 4):\n\t\tObstacle.__init__(self)\n\t\tself.pos = pos\n\t\tpoints = []\n\t\tsphericals = []\n\t\t# Generate a number of points in spherical coordinates\n\t\tfor x in xrange(num):\n\t\t\trad = x*(2*numpy.pi/num)\n\t\t\tdist = corerandom.gauss(radius/2, sigma/2) #random.randint(0,radius)\n\t\t\tif dist < min:\n\t\t\t\tdist = min\n\t\t\tif dist > radius:\n\t\t\t\tdist = radius\n#\t\t\tprint \"dist\", dist\n\t\t\tsphericals.append((rad, dist))\n\t\t# Convert to cartesian coordinates\n\t\tfor (rad, dist) in sphericals:\n\t\t\tpoints.append(((int(math.cos(rad)*dist)+radius), int((math.sin(rad)*dist)+radius)))\n\t\t# Create surface\n\t\ts = pygame.Surface((radius*2, radius*2), pygame.SRCALPHA, 32)\n\t\ts = s.convert_alpha()\n\t\t# Draw polygon on surface\n\t\tpygame.draw.lines(s, color, True, points, linewidth)\n\t\t# translate points to absolute space\n\t\ttranspoints = []\n\t\tfor p in points:\n\t\t\ttranspoints.append((p[0] + self.pos[0], p[1] + self.pos[1]))\n\t\t# Make lines\n\t\tlines = []\n\t\tp_last = None\n\t\tfor p in transpoints:\n\t\t\tif p_last != None:\n\t\t\t\tlines.append((p_last, p))\n\t\t\tp_last = p\n\t\tlines.append((transpoints[len(transpoints)-1], transpoints[0]))\n\t\t# Store some stuff\n\t\tself.rect = s.get_rect()\n\t\tself.surface = s\n\t\tself.lines = lines\n\t\tself.points = transpoints\n#\t\tprint \"points\", self.points\n\t\t\n\t\t\n#\n\t\t\n\t\t\n############################\n### ManualObstacle\n\t\t\nclass ManualObstacle(Obstacle):\n\n\t### Note: the points are sorted in order of increasing angle around a central point.\n\n\t### points: points of the polygon relative to center\n\t### pos: center of polygon\n\t### lines: lines of polygon relative to center\n\t### surface: the surface\n\t### rect: the rectangle of the surface\n\t### sprites: the sprite group for all decorations (redundant with self.decorations, but just easier this way)\n\t### decorations: the decorations\n\t\t\n\t### Constructor\n\t# pos = center point of polygon\n\t# Points must be in clockwise or counterclockwise order, and relative to (0,0)\n\t# color = line color\n\t# linewidth = width of the lines\n\tdef __init__(self, points, color = (0, 0, 0), linewidth = 4, sprite = None):\n\t\tObstacle.__init__(self)\n\t\tminpt = ( min(map(lambda p: p[0], points)), min(map(lambda p: p[1], points)) )\n\t\tmaxpt = ( max(map(lambda p: p[0], points)), max(map(lambda p: p[1], points)) )\n\t\t# create surface\n\t\ts = pygame.Surface((maxpt[0]+linewidth, maxpt[1]+linewidth), pygame.SRCALPHA, 32)\n\t\ts = s.convert_alpha()\n\t\tpygame.draw.lines(s, color, True, points, linewidth)\n\t\tself.surface = s\n\t\tself.rect = s.get_rect()\n\t\t#transpoints = []\n\t\t#for p in points:\n\t\t#\ttranspoints.append((p[0] + self.pos[0], p[1] + self.pos[1]))\n\t\t#self.points = transpoints\n\t\tself.points = points\n\t\t# compute lines\n\t\tlines = []\n\t\tlast = None\n\t\tfor p in points:\n\t\t\tif last != None:\n\t\t\t\tlines.append((last, p))\n\t\t\tlast = p\n\t\tlines.append((points[len(points)-1], points[0]))\n\t\tself.lines = lines\n\t\t# Decorations\n\t\tself.decorations = []\n\t\tself.sprites = pygame.sprite.RenderPlain()\n\t\tif sprite is not None:\n\t\t\tdec = Decoration(sprite, (0, 0))\n\t\t\tpos = (0, 0)\n\t\t\tfor x in xrange((self.rect.width*2)/dec.rect.width):\n\t\t\t\tfor y in xrange((self.rect.height*2)/dec.rect.height):\n\t\t\t\t\tpos = (((x/2)*dec.rect.width)+corerandom.uniform(0, dec.rect.width/5.0), ((y/2)*dec.rect.height)+corerandom.uniform(0, dec.rect.height/5.0))\n\t\t\t\t\torient = corerandom.uniform(0, 360.0)\n\t\t\t\t\tif pointInsidePolygonPoints((pos[0]+dec.rect.width/2.0, pos[1]+dec.rect.height/2.0), points):\n\t\t\t\t\t\td = Decoration(sprite, pos, orient)\n\t\t\t\t\t\tself.decorations.append(d)\n\t\t\t\t\t\tself.sprites.add(d)\n\n\t### Draw me\n\tdef draw(self, parent):\n\t\tObstacle.draw(self, parent)\n\t\tself.sprites.draw(self.surface)\n\n############################\n### GameWorld\n\nclass GameWorld():\n\n\t### screen: the screen\n\t### background: the background surface\n\t### agent: the player agent\n\t### obstacles: obstacles\n\t### sprites: all sprites (player and NPCs)\n\t### npcs: the NPC agents\n\t### dimensions: the size of the world (width, height)\n\t### points: all the points of obstacles, plus screen corners\n\t### lines: all the points of obstacles, plus screen edges\n\t### bullets: all the bullets active\n\t### resources: all the resources\n\t### movers: all things that can collide with other things and implement collision()\n\t### destinations: places that are not inside of obstacles. \n\t### clock: elapsed time in game\n\n\tdef __init__(self, seed, worlddimensions, screendimensions):\n\t\t#initialize random seed\n\t\tself.time = time.time()\n\t\tcorerandom.seed(seed or self.time)\n\t\trandom.seed(self.time)\n\t\t#initialize pygame and set up screen and background surface\n\t\tpygame.init()\n\t\tscreen = pygame.display.set_mode(screendimensions)\n\t\t# Background surface that will hold everything\n#\t\tbackground = pygame.Surface(screen.get_size())\n\t\tbackground = pygame.Surface(worlddimensions)\n\t\tbackground = background.convert()\n\t\tbackground.fill((255, 255, 255))\n\t\t# Debug surface\n\t\tdebug = pygame.Surface(worlddimensions)\n\t\tdebug = debug.convert()\n\t\tdebug.fill((255, 255, 255))\n\t\tbackground.blit(debug, (0, 0))\n\t\tscreen.blit(background, (0, 0))\n\t\tpygame.display.flip()\n\t\t#store stuff\n\t\tself.screen = screen\n\t\tself.seed = seed or self.time\n\t\tself.background = background\n\t\tself.debug = debug\n\t\tself.obstacles = None\n\t\tself.sprites = None\n\t\tself.agent = None\n\t\tself.npcs = []\n\t\tself.dimensions = worlddimensions\n\t\tself.points = None \n\t\tself.lines = None \n\t\tself.bullets = []\n\t\tself.resources = []\n\t\tself.debugging = False\n\t\tself.movers = []\n\t\tself.clock = 0\n\t\t# camera\n\t\tself.camera = [0, 0]\n\t\t# unobstructed places\n\t\tself.destinations = {}\n\t\n\tdef getPoints(self):\n\t\treturn self.points\n\t\n\tdef getLines(self):\n\t\treturn self.lines\n\t\n\tdef getLinesWithoutBorders(self):\n\t\tcorners = [(0, 0), (self.dimensions[0], 0), (self.dimensions[0], self.dimensions[1]), (0, self.dimensions[1])]\n\t\tlines = []\n\t\tfor l in self.getLines():\n\t\t\tif not (l[0] in corners and l[1] in corners):\n\t\t\t\tlines.append(l)\n\t\treturn lines\n\n\t\n\tdef getObstacles(self):\n\t\treturn self.obstacles\n\t\n\tdef getDimensions(self):\n\t\treturn self.dimensions\n\t\t\n\tdef setPlayerAgent(self, agent):\n\t\tself.agent = agent\n\t\tself.camera = agent.getLocation()\n\t\tself.movers.append(agent)\n#\t\tprint agent.radius\n\n\t# Make Random Terrain\n\tdef initializeRandomTerrain(self, num, onum, radius, sigma, min):\n\t\tobstacles = []\n\t\tpoints = [(0, 0), (self.dimensions[0], 0), (self.dimensions[0], self.dimensions[1]), (0, self.dimensions[1])]\n\t\tlines = [((0, 0), (self.dimensions[0], 0)), ((self.dimensions[0], 0), (self.dimensions[0], self.dimensions[1])), ((self.dimensions[0], self.dimensions[1]), (0, self.dimensions[1])), ((0, self.dimensions[1]), (0,0))]\n\t\tfor _ in xrange(num):\n\t\t\tpos = [0, 0]\n\t\t\tfor _ in xrange(100):\n\t\t\t\tpos = [corerandom.randint(0,self.dimensions[0]-radius), corerandom.randint(0,self.dimensions[1]-radius)]\n\t\t\t\ttooclose = False\n\t\t\t\tfor o in obstacles:\n\t\t\t\t\tif distance(pos, o.pos) < radius*2:\n\t\t\t\t\t\ttooclose = True\n\t\t\t\tif tooclose == False:\n\t\t\t\t\tbreak\n\t\t\to = RandomObstacle(onum, pos, radius, sigma, min)\n\t\t\tobstacles.append(o)\n\t\t\tpoints = points + o.getPoints()\n\t\t\tlines = lines + o.getLines()\n\t\tself.obstacles = obstacles\n\t\tself.points = points\n\t\tself.lines = lines \n\t\t\n\t# Make Terrain\n\t# polys = list of list points (poly1, poly2, ...) = ((p11, p12, ...), (p21, p22, ...), ...)\n\tdef initializeTerrain(self, polys, color = (0, 0, 0), linewidth = 4, sprite = None):\n\t\tobstacles = []\n\t\tpoints = [(0, 0), (self.dimensions[0], 0), (self.dimensions[0], self.dimensions[1]), (0, self.dimensions[1])]\n\t\tlines = [((0, 0), (self.dimensions[0], 0)), ((self.dimensions[0], 0), (self.dimensions[0], self.dimensions[1])), ((self.dimensions[0], self.dimensions[1]), (0, self.dimensions[1])), ((0, self.dimensions[1]), (0,0))]\n\t\tfor poly in polys:\n\t\t\t#minpt = (min(map(lambda p: p[0], poly)), min(map(lambda p: p[1], poly)))\n\t\t\t#maxpt = (max(map(lambda p: p[0], poly)), max(map(lambda p: p[1], poly)))\n\t\t\t#center = [ (sum(map(lambda p: p[0], poly))/float(len(poly)))-((maxpt[0]-minpt[0])/2.0), (sum(map(lambda p: p[1], poly))/float(len(poly)))-((maxpt[1]-minpt[1])/2.0) ]\n\t\t\t#newpoly = map(lambda pt: (pt[0] - minpt[0], pt[1] - minpt[1]), poly)\n\t\t\to = ManualObstacle(poly, color, linewidth, sprite)\n\t\t\tpoints = points + o.getPoints()\n\t\t\tlines = lines + o.getLines()\n\t\t\tobstacles.append(o)\n\t\tself.obstacles = obstacles\n\t\tself.points = points\n\t\tself.lines = lines\n\n\n\tdef initializeResources(self, points, resource = RESOURCE):\n\t\tfor point in points:\n\t\t\tr = SimpleResource(resource, point, 0, self)\n\t\t\tself.addResource(r)\n\t\n\n\tdef initializeRandomResources(self, num, resource = RESOURCE):\n\t\tfor _ in xrange(num):\n\t\t\tpos = (0, 0)\n\t\t\twhile True:\n\t\t\t\tpos = (corerandom.randint(0, self.dimensions[0]), corerandom.randint(0, self.dimensions[1]))\n\t\t\t\tinside = False\n\t\t\t\tfor o in self.obstacles:\n\t\t\t\t\tif pointInsidePolygonPoints(pos, o.getPoints()):\n\t\t\t\t\t\tinside = True\n\t\t\t\tif inside == False:\n\t\t\t\t\tbreak\n\t\t\tr = SimpleResource(resource, pos, 0, self)\n\t\t\tself.addResource(r)\n#\t\t\tself.resources.add(r)\n#\t\t\tself.movers.add(r)\n\n\tdef run(self):\n\t\tself.sprites = pygame.sprite.RenderPlain((self.agent))\n#\t\tfor r in self.resources:\n#\t\t\tself.sprites.add(r)\n#\t\tfor n in self.npcs:\n#\t\t\tself.sprites.add(n)\n\t\tfor m in self.movers:\n\t\t\tself.sprites.add(m)\n\t\tclock = pygame.time.Clock()\n\t\t\n\t\t# Draw obstacles. Only need to do this once\n\t\tfor o in self.obstacles:\n\t\t\to.draw(self.background)\n\n\t\twhile True:\n\t\t\tclock.tick(TICK)\n\t\t\tdelta = clock.get_rawtime()\n\t\t\tself.handleEvents()\n\t\t\tself.update(delta)\n\t\t\tself.sprites.update(delta) \n\t\t\t#print \"obstacles\"\n\t\t\t#for o in self.obstacles:\n\t\t\t#\tprint o.pos\n\t\t\t#\to.pos[0] = o.pos[0] + 1.0\n\t\t\t#\to.pos[1] = o.pos[1] + 1.0\n\t\t\tself.drawWorld()\n\t\t\tpygame.display.flip()\n\t\t\t\n\tdef drawWorld(self):\n\t\t#self.screen.blit(self.background, (0, 0))\n\t\toffsetX = self.camera[0] - self.agent.rect.center[0]\n\t\toffsetY = self.camera[1] - self.agent.rect.center[1]\n\t\tself.screen.fill((255, 255, 255))\n\t\tself.screen.blit(self.background, [offsetX, offsetY])\n\t\tif self.debugging:\n\t\t\tself.background.blit(self.debug, (0, 0))\n\t\tself.sprites.draw(self.background)\n\t\tfor o in self.obstacles:\n\t\t\to.draw(self.background)\n\t\t#pygame.display.flip()\n\t\t\n\tdef handleEvents(self): \n\t\tevents = pygame.event.get()\n\t\tfor event in events:\n\t\t\tif event.type == QUIT:\n\t\t\t\tsys.exit(0) \n\t\t\telif event.type == MOUSEBUTTONUP:\n\t\t\t\tself.doMouseUp()\n\t\t\telif event.type == KEYDOWN:\n\t\t\t\tself.doKeyDown(event.key)\n\t\t\t\t\n\tdef doMouseUp(self):\n\t\tpos = pygame.mouse.get_pos()\n\t\toffsetX = pos[0] + self.agent.rect.center[0] - self.camera[0]\n\t\toffsetY = pos[1] + self.agent.rect.center[1] - self.camera[1]\n\t\tself.agent.navigateTo([offsetX, offsetY])\n\t\t\n\n\tdef doKeyDown(self, key):\n\t\tif key == 32: #space\n\t\t\tself.agent.shoot()\n\t\telif key == 100: #d\n\t\t\tprint \"distance traveled\", self.agent.distanceTraveled\n\n\tdef worldCollisionTest(self):\n\t\tcollisions = []\n\t\tfor m1 in self.movers:\n\t\t\tif m1 in self.movers:\n\t\t\t\t# Collision against world boundaries\n\t\t\t\tif m1.rect.center[0] < 0 or m1.rect.center[0] > self.dimensions[0] or m1.rect.center[1] < 0 or m1.rect.center[1] > self.dimensions[1]:\n\t\t\t\t\tcollisions.append((m1, self))\n\t\t\t\t# Collision against obstacles\n\t\t\t\tfor o in self.obstacles:\n\t\t\t\t\tc = False\n\t\t\t\t\tfor l in o.getLines():\n\t\t\t\t\t\tfor r in ((m1.rect.topleft, m1.rect.topright), (m1.rect.topright, m1.rect.bottomright), (m1.rect.bottomright, m1.rect.bottomleft), (m1.rect.bottomleft, m1.rect.topleft)):\n\t\t\t\t\t\t\thit = calculateIntersectPoint(l[0], l[1], r[0], r[1])\n\t\t\t\t\t\t\tif hit is not None:\n\t\t\t\t\t\t\t\tc = True\n\t\t\t\t\tif c:\n\t\t\t\t\t\tcollisions.append((m1, o))\n\t\t\t\t# Movers against movers\n\t\t\t\tfor m2 in self.movers:\n\t\t\t\t\tif m2 in self.movers:\n\t\t\t\t\t\tif m1 != m2:\n\t\t\t\t\t\t\tif (m1, m2) not in collisions and (m2, m1) not in collisions:\n\t\t\t\t\t\t\t\tif m1.rect.colliderect(m2.rect):\n\t\t\t\t\t\t\t\t\tcollisions.append((m1, m2))\n\t\tfor c in collisions:\n\t\t\tc[0].collision(c[1])\n\t\t\tc[1].collision(c[0])\n\t\t\n\tdef update(self, delta):\n\t\tself.clock = self.clock + delta\n\t\tself.worldCollisionTest()\n\t\treturn None\n\t\t\n\tdef collision(self, thing):\n\t\treturn None\n\t\t\n\tdef getLines(self):\n\t\treturn self.lines[:]\n\n\tdef getPoints(self):\n\t\treturn self.points[:]\n\t\t\n\tdef addBullet(self, bullet):\n\t\tself.bullets.append(bullet)\n\t\tif self.sprites is not None:\n\t\t\tself.sprites.add(bullet)\n\t\tself.movers.append(bullet)\n\t\t\n\tdef deleteBullet(self, bullet):\n\t\tif bullet in self.bullets:\n\t\t\tself.bullets.remove(bullet)\n\t\t\tif self.sprites is not None:\n\t\t\t\tself.sprites.remove(bullet)\n\t\t\tself.movers.remove(bullet)\n\n\tdef addResource(self, res):\n\t\tself.resources.append(res)\n\t\tif self.sprites is not None:\n\t\t\tself.sprites.add(res)\n\t\tself.movers.append(res)\n\t\n\tdef deleteResource(self, res):\n\t\tself.resources.remove(res)\n\t\tif self.sprites is not None:\n\t\t\tself.sprites.remove(res)\n\t\tself.movers.remove(res)\n\t\t\n\tdef addNPC(self, npc):\n\t\tself.npcs.append(npc)\n\t\tif self.sprites is not None:\n\t\t\tself.sprites.add(npc)\n\t\tself.movers.append(npc)\n\t\t\n\tdef deleteNPC(self, npc):\n\t\tif npc in self.npcs:\n\t\t\tself.npcs.remove(npc)\n\t\t\tif self.sprites is not None:\n\t\t\t\tself.sprites.remove(npc)\n\t\t\tself.movers.remove(npc)\n\n\tdef getVisible(self, position, orientation, viewangle, type = None):\n\t\tvisible = []\n\t\tfor m in self.movers:\n\t\t\tif type == None or isinstance(m, type):\n\t\t\t\t# m is the type that we are looking for\n\t\t\t\tother = m.getLocation()\n\t\t\t\tif other != position:\n\t\t\t\t\t# other is not me\n\t\t\t\t\tif viewangle < 360:\n\t\t\t\t\t\t# viewangle less than 360\n\t\t\t\t\t\torient = (math.cos(math.radians(orientation)), -math.sin(math.radians(orientation)))\n\t\t\t\t\t\tvect = (other[0]-position[0], other[1]-position[1])\n\t\t\t\t\t\tx = dotProduct(orient, vect) / (vectorMagnitude(orient) * vectorMagnitude(vect))\n\t\t\t\t\t\tif x >= 1.0:\n\t\t\t\t\t\t\tangle = 0.0\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tangle = math.degrees(math.acos(x))\n\t\t\t\t\t\tif angle < viewangle/2.0:\n\t\t\t\t\t\t\thit = rayTraceWorld(position, other, self.getLines())\n\t\t\t\t\t\t\tif hit == None:\n\t\t\t\t\t\t\t\tvisible.append(m)\n\t\t\t\t\telse:\n\t\t\t\t\t\t# viewangle is 360\n\t\t\t\t\t\thit = rayTraceWorld(position, other, self.getLines())\n\t\t\t\t\t\tif hit == None:\n\t\t\t\t\t\t\tvisible.append(m)\n\t\treturn visible\n\n\tdef computeFreeLocations(self, agent):\n\t\tif type(agent) not in self.destinations:\n\t\t\tdestinations = []\n\t\t\tgrid = agent.getRadius()*2.0\n\t\t\tfor x in xrange(1, int(self.dimensions[0]/grid)):\n\t\t\t\tfor y in xrange(1, int(self.dimensions[1]/grid)):\n\t\t\t\t\tpoint = (x*grid, y*grid)\n\t\t\t\t\tif isGood(point, self, grid):\n\t\t\t\t\t\tdestinations.append(point)\n\t\t\tself.destinations[type(agent)] = destinations\n\t\t\n\tdef getFreeLocations(self, agent):\n\t\tif type(agent) in self.destinations:\n\t\t\treturn self.destinations[type(agent)]\n\t\telse:\n\t\t\treturn None\n\t\t\t\t\t\n\tdef getNPCs(self):\n\t\treturn self.npcs\n\n\tdef getAgent(self):\n\t\treturn self.agent\n\n\tdef getBullets(self):\n\t\treturn self.bullets\n\n############################\n### GATE\n\nclass Gate(Thing, Blocker):\n\n\tdef __init__(self, p1, p2, sprite, world):\n\t\tself.line = (p1, p2)\n\t\tself.sprites = pygame.sprite.RenderPlain()\n\t\tself.decorations = []\n\t\t#self.active = active\n\t\tdec = Decoration(sprite, (0, 0)) # throw away\n\t\tsize = max(dec.rect.height, dec.rect.width)\n\t\tlength = int(distance(p1, p2))\n\t\tfor t in xrange(length/size):\n\t\t\tpos = (p1[0] + ((float(t)/length) * size * (p2[0] - p1[0])), p1[1] + ((float(t)/length) * size * (p2[1] - p1[1])))\n\t\t\td = Decoration(sprite, pos, 0)\n\t\t\tself.decorations.append(d)\n\t\t\tself.sprites.add(d)\n\n\tdef getLine(self):\n\t\treturn self.line\n\t\n\tdef draw(self, parent):\n\t\tself.sprites.draw(parent)\n\t\t\t\n\tdef isColliding(self, rect):\n\t\tfor d in self.decorations:\n\t\t\tif d.rect.colliderect(rect):\n\t\t\t\treturn True\n\t\treturn False\n\ndef getGateLine(gate):\n\treturn gate.getLine()\n\n############################\n### GatedWorld\n\t\t\t\nclass GatedWorld(GameWorld):\n\n\t### Gates: lines (p1, p2) where gates can appear\n\t### timer: running timer\n\t### alarm: when timer is greater than this number, gate switches\n\t### gate: the active gate\n\n\tdef __init__(self, seed, worlddimensions, screendimensions, numgates, alarm):\n\t\tGameWorld.__init__(self, seed, worlddimensions, screendimensions)\n\t\tself.potentialGates = []\n\t\tself.timer = 0\n\t\tself.alarm = alarm\n\t\tself.gates = []\n\t\tself.numGates = numgates\n\t\n\tdef getNumGates(self):\n\t\treturn self.numGates\n\t\n\tdef getGates(self):\n\t\treturn map(getGateLine, self.gates)\n\t\n\tdef makePotentialGates(self):\n\t\tif self.obstacles != None:\n\t\t\tdangerpoints = [(0, 0), (self.dimensions[0], 0), (self.dimensions[0], self.dimensions[1]), (0, self.dimensions[1])]\n\t\t\tfor p1 in self.getPoints():\n\t\t\t\tfor p2 in self.getPoints():\n\t\t\t\t\tif p1 != p2: # and p2 != (0, 0) and p2 != (self.dimensions[0], 0) and p2 != (self.dimensions[0], self.dimensions[1]) and p2 != (0, self.dimensions[1]):\n\t\t\t\t\t\tif (p1 not in dangerpoints) or (p2 not in dangerpoints):\n\t\t\t\t\t\t\tsamepoly = False\n\t\t\t\t\t\t\tfor o in self.obstacles:\n\t\t\t\t\t\t\t\tif p1 in o.getPoints() and p2 in o.getPoints():\n\t\t\t\t\t\t\t\t\tsamepoly = True\n\t\t\t\t\t\t\tif samepoly == False:\n\t\t\t\t\t\t\t\tif not insideObstacle(((p1[0]+p2[0])/2.0, (p1[1]+p2[1])/2.0), self.obstacles):\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\thit = rayTraceWorldNoEndPoints(p1, p2, self.getLines())\n\t\t\t\t\t\t\t\t\tif hit == None:\n\t\t\t\t\t\t\t\t\t\tself.potentialGates.append((p1, p2))\n\n\tdef drawWorld(self):\n\t\tGameWorld.drawWorld(self)\n\t\tfor g in self.gates:\n\t\t\tg.draw(self.background)\n\t\t\t\n\n\tdef worldCollisionTest(self):\n\t\tGameWorld.worldCollisionTest(self)\n\t\tfor g in self.gates:\n\t\t\tfor m in self.movers:\n\t\t\t\tif g.isColliding(m.rect):\n\t\t\t\t\tm.collision(g)\n\t\t\t\t\tg.collision(m)\n\t\t\t\t\n\n\tdef update(self, delta):\n\t\tGameWorld.update(self, delta)\n\t\tself.timer = self.timer + 1\n\t\tif self.timer > self.alarm:\n\t\t\tself.timer = 0\n\t\t\tif len(self.potentialGates) > 0:\n\t\t\t\tnewgates = []\n\t\t\t\tfor x in xrange(self.numGates):\n\t\t\t\t\tr = corerandom.randint(0, len(self.potentialGates)-1)\n\t\t\t\t\tline = self.potentialGates[r]\n\t\t\t\t\ttooclose = False\n\t\t\t\t\tfor m in self.movers:\n\t\t\t\t\t\tif minimumDistance(line, m.getLocation()) < m.getRadius()*4.0:\n\t\t\t\t\t\t\ttooclose = True\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif tooclose == False:\n\t\t\t\t\t\tg = Gate(line[0], line[1], GATE, self)\n\t\t\t\t\t\tnewgates.append(g)\n\t\t\t\t\telif len(self.gates) > x:\n\t\t\t\t\t\tnewgates.append(self.gates[x])\n\t\t\t\tself.gates = newgates\n\t\treturn None\n\n\n\t\t\n\t### NOTE: really should get the bounding box and return the lines of the bounding box\n\tdef getLines(self):\n\t\tlines = GameWorld.getLines(self)\n\t\tfor g in self.gates:\n\t\t\tlines.append(g.line)\n\t\treturn lines\n\n\tdef doKeyDown(self, key):\n\t\tGameWorld.doKeyDown(self, key)\n\t\tif key == 103: #'g'\n\t\t\tpos = pygame.mouse.get_pos()\n\t\t\toffsetX = pos[0] + self.agent.rect.center[0] - self.camera[0]\n\t\t\toffsetY = pos[1] + self.agent.rect.center[1] - self.camera[1]\n\t\t\tself.addGateAtNearest((offsetX, offsetY))\n\n\tdef drawPotentialGates(self):\n\t\tfor g in self.potentialGates:\n\t\t\tpygame.draw.line(self.debug, (225, 225, 225), g[0], g[1], 1)\n\n\n\tdef addGateAtNearest(self, point):\n\t\tif len(self.potentialGates) > 0 and self.numGates > 0:\n\t\t\tbestGate = None\n\t\t\tbestDist = 0\n\t\t\tfor cur in self.potentialGates:\n\t\t\t\td = minimumDistance(cur, point)\n\t\t\t\tif bestGate is None or d < bestDist:\n\t\t\t\t\tbestGate = cur\n\t\t\t\t\tbestDist = d\n\t\t\tg = Gate(bestGate[0], bestGate[1], GATE, self)\n\t\t\tself.gates.append(g)\n\t\t\tif len(self.gates) > self.numGates:\n\t\t\t\tself.gates.pop(0)\n\n#######################################\n### HELPERS\n\t\n\ndef insideObstacle(point, obstacles):\n\tfor o in obstacles:\n\t\tif pointInsidePolygonPoints(point, o.getPoints()):\n\t\t\treturn True\n\treturn False\t\t\n\t\t\t\t\ndef isGood(point, world, threshold):\n\tif point[0] > 0 and point[0] < world.dimensions[0] and point[1] > 0 and point[1] < world.dimensions[1]:\n\t\tfor o in world.obstacles:\n\t\t\tif pointInsidePolygonPoints(point, o.getPoints()):\n\t\t\t\treturn False\n\t\tfor l in world.getLines():\n\t\t\tif minimumDistance(l, point) < threshold:\n\t\t\t\treturn False\n\t\treturn True\n\treturn False\n\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"id":"2","maintainHistory":true,"markersById":{"1":{"range":{"start":{"row":1,"column":28},"end":{"row":1,"column":58}},"properties":{"type":"selection","goalScreenRange":null},"reversed":false,"tailed":true,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":2,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/vmaudgalya/Downloads/homework1/core.py","digestWhenLastPersisted":"c7a4f1fa4d93d92dc8b889056b5ab514a6855228","preferredLineEnding":null,"nextMarkerId":2,"deserializer":"TextBuffer","version":5}]},"workspace":{"deserializer":"Workspace","paneContainer":{"deserializer":"PaneContainer","version":1,"root":{"deserializer":"Pane","id":3,"items":[{"deserializer":"TextEditor","id":4,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":5,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferId":"f04f80680f4adfec4e45b9f24ee26df2","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":8,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":9,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/vmaudgalya/Downloads/homework1/rungreedygridnavigator1.py","bufferId":"ce5471c89289b095f11535d989468137","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":12,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":13,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/vmaudgalya/Downloads/homework1/constants.py","bufferId":"dab4e908e53706e97c304da1f863729b","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":16,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":17,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/vmaudgalya/Downloads/homework1/core.py","bufferId":"3192ff0ad127b6ed59987222b98e8653","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"}],"activeItemURI":"/Users/vmaudgalya/Downloads/homework1/core.py","focused":true,"flexScale":1},"activePaneId":3},"packagesWithActiveGrammars":["language-python","language-sql","language-hyperlink","language-todo"],"destroyedItemURIs":[]},"packageStates":{"linter":{"scope":"File"},"pigments":{"project":{"deserializer":"ColorProject","timestamp":"2016-01-25T03:37:21.264Z","version":"1.0.1","markersVersion":"1.0.5","globalSourceNames":["**/*.styl","**/*.stylus","**/*.less","**/*.sass","**/*.scss"],"globalIgnoredNames":["vendor/*","node_modules/*","spec/*","test/*"],"buffers":{"4":{"id":4,"colorMarkers":[]},"8":{"id":8,"path":"/Users/vmaudgalya/Downloads/homework1/rungreedygridnavigator1.py","colorMarkers":[]},"12":{"id":12,"path":"/Users/vmaudgalya/Downloads/homework1/constants.py","colorMarkers":[]},"16":{"id":16,"path":"/Users/vmaudgalya/Downloads/homework1/core.py","colorMarkers":[]}},"paths":[],"variables":{"deserializer":"VariablesCollection","content":[]}}},"fuzzy-finder":{"/Users/vmaudgalya/Downloads/homework1/rungreedygridnavigator1.py":1453690252040,"/Users/vmaudgalya/Downloads/homework1/constants.py":1453690260918,"/Users/vmaudgalya/Downloads/homework1/core.py":1453690262180},"metrics":{"sessionLength":3147718},"tabs":[{}],"tree-view":{"directoryExpansionStates":{"/Users/vmaudgalya/Downloads/homework1":{"isExpanded":true,"entries":{"instructions":{"isExpanded":false,"entries":{}},"sprites":{"isExpanded":false,"entries":{}}}}},"selectedPath":"/Users/vmaudgalya/Downloads/homework1/core.py","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":248}},"fullScreen":false}