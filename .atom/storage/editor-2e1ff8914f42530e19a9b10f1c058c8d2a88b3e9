{"version":1,"windowDimensions":{"x":0,"y":23,"width":1144,"height":851,"maximized":false},"grammars":{"grammarOverridesByPath":{}},"project":{"deserializer":"Project","paths":["/Users/vmaudgalya/projects/personal/library"],"buffers":[{"text":"/***\n* @author Varun Maudgalya\n* Stack Implementation using resizing array\n* O(1) ammortized push/pop\n***/\n\nimport java.util.Iterator;\n\npublic class Stack<E> implements Iterable<E> {\n\n  E[] stack;\n  int N; // Points to next insertion point\n  int size;\n\n  @SuppressWarnings(\"unchecked\")\n  public Stack() {\n    this.stack = (E[]) new Object[1];\n    this.size = 0;\n    this.N = 0;\n  }\n\n  public int size() {\n    return this.size;\n  }\n\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private void resize(final int newLength) {\n    E[] resizedStack = (E[]) new Object[newLength];\n    for (int i = 0; i < N; i++) {\n      resizedStack[i] = this.stack[i];\n    }\n    this.stack = resizedStack;\n  }\n\n  public void push(final E data) {\n    if (data == null) {\n      return;\n    }\n    stack[this.N++] = data;\n    if (this.N >= this.stack.length) {\n      this.resize(2*this.stack.length);\n    }\n    size++;\n  }\n\n  public E peek() {\n    if (this.isEmpty()) {\n      return null; // Error\n    }\n    return stack[N-1];\n  }\n\n  public E pop() {\n    if (this.isEmpty()) {\n      return null; // Error\n    }\n    final E data = stack[--this.N];\n    stack[N] = null; // Avoid data loitering\n    size--;\n    return data;\n  }\n\n  public Iterator<E> iterator() {\n    return new StackIterator();\n  }\n\n  private class StackIterator implements Iterator<E> {\n\n\n    private int index;\n\n    public StackIterator() {\n      this.index = 0;\n    }\n\n    @Override\n    public boolean hasNext() {\n      return this.index < N;\n    }\n\n    @Override\n    public E next() {\n      if (this.hasNext()) {\n        return stack[index++];\n      }\n      return null; // Error\n    }\n\n    @Override\n    public void remove() {\n      /* Modification of a list during iteration is not recommended. */\n      throw new UnsupportedOperationException(\"remove() is not supported by this API\");\n    }\n\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder builder = new StringBuilder(\"---TOP---\\n\");\n    for (int i = N-1; i >= 0; i--) {\n      builder.append(stack[i] + \"\\n\");\n    }\n    builder.append(\"--BOTTOM--\\n\");\n    return builder.toString();\n  }\n\n}\n","markerStore":{"nextMarkerId":13,"markersById":{"0":{"range":{"start":{"row":110,"column":1},"end":{"row":110,"column":1}},"properties":{"type":"selection","editorId":8,"goalScreenRange":null,"preserveFolds":true},"reversed":false,"tailed":true,"valid":true,"invalidate":"never","maintainHistory":true},"3":{"range":{"start":{"row":110,"column":0},"end":{"row":110,"column":1}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":false},"4":{"range":{"start":{"row":8,"column":45},"end":{"row":8,"column":46}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":false},"11":{"range":{"start":{"row":110,"column":0},"end":{"row":110,"column":1}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":false},"12":{"range":{"start":{"row":8,"column":45},"end":{"row":8,"column":46}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":false}},"version":2},"history":{"version":3,"nextCheckpointId":6,"undoStack":[{"type":"group-start","snapshot":{"0":{"range":[[0,0],[0,0]],"properties":{"type":"selection","editorId":8},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}}},{"type":"change","content":{"oldRange":[[0,0],[0,0]],"newRange":[[0,0],[111,0]],"oldText":"","newText":"/***\n* @author Varun Maudgalya\n* Stack Implementation using resizing array\n* O(1) ammortized push/pop\n***/\n\nimport java.util.Iterator;\n\npublic class Stack<E> implements Iterable<E> {\n\n  E[] stack;\n  int N; // Points to next insertion point\n  int size;\n\n  @SuppressWarnings(\"unchecked\")\n  public Stack() {\n    this.stack = (E[]) new Object[1];\n    this.size = 0;\n    this.N = 0;\n  }\n\n  public int size() {\n    return this.size;\n  }\n\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private void resize(final int newLength) {\n    E[] resizedStack = (E[]) new Object[newLength];\n    for (int i = 0; i < N; i++) {\n      resizedStack[i] = this.stack[i];\n    }\n    this.stack = resizedStack;\n  }\n\n  public void push(final E data) {\n    if (data == null) {\n      return;\n    }\n    stack[this.N++] = data;\n    if (this.N >= this.stack.length) {\n      this.resize(2*this.stack.length);\n    }\n    size++;\n  }\n\n  public E peek() {\n    if (this.isEmpty()) {\n      return null; // Error\n    }\n    return stack[N-1];\n  }\n\n  public E pop() {\n    if (this.isEmpty()) {\n      return null; // Error\n    }\n    final E data = stack[--this.N];\n    stack[N] = null; // Avoid data loitering\n    size--;\n    return data;\n  }\n\n  public Iterator<E> iterator() {\n    return new StackIterator();\n  }\n\n  private class StackIterator implements Iterator<E> {\n\n\n    private int index;\n\n    public StackIterator() {\n      this.index = 0;\n    }\n\n    @Override\n    public boolean hasNext() {\n      return this.index < N;\n    }\n\n    @Override\n    public E next() {\n      if (this.hasNext()) {\n        return stack[index++];\n      }\n      return null; // Error\n    }\n\n    @Override\n    public void remove() {\n      /* Modification of a list during iteration is not recommended. */\n      throw new UnsupportedOperationException(\"remove() is not supported by this API\");\n    }\n\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder builder = new StringBuilder(\"---TOP---\\n\");\n    for (int i = N-1; i >= 0; i--) {\n      builder.append(stack[i] + \"\\n\");\n    }\n    builder.append(\"--BOTTOM--\\n\");\n    return builder.toString();\n  }\n\n}\n"}},{"type":"change","content":{"oldRange":[[0,0],[0,0]],"newRange":[[0,0],[0,0]],"oldText":"","newText":""}},{"type":"group-end","snapshot":{"0":{"range":[[111,0],[111,0]],"properties":{"type":"selection","editorId":8,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}}},{"type":"group-start","snapshot":{"0":{"range":[[111,0],[111,0]],"properties":{"type":"selection","editorId":8,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}}},{"type":"change","content":{"oldRange":[[110,1],[111,0]],"newRange":[[110,1],[110,1]],"oldText":"\n","newText":""}},{"type":"group-end","snapshot":{"0":{"range":[[110,1],[110,1]],"properties":{"type":"selection","editorId":8,"goalScreenRange":null},"reversed":true,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}}},{"type":"group-start","snapshot":{"0":{"range":[[110,1],[110,1]],"properties":{"type":"selection","editorId":8,"goalScreenRange":null},"reversed":true,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}}},{"type":"change","content":{"oldRange":[[110,1],[110,1]],"newRange":[[110,1],[111,0]],"oldText":"","newText":"\n"}},{"type":"group-end","snapshot":{"0":{"range":[[110,1],[110,1]],"properties":{"type":"selection","editorId":8,"goalScreenRange":null},"reversed":false,"tailed":true,"valid":true,"invalidate":"never","maintainHistory":true}}}],"redoStack":[]},"encoding":"utf8","filePath":"/Users/vmaudgalya/projects/personal/library/data_structures/Stack.java","digestWhenLastPersisted":"f936068b6982d9f5b17101efc0ec12a265ad5f0a","preferredLineEnding":"\n","deserializer":"TextBuffer","version":2},{"text":"/***\n* @author Varun Maudgalya\n* Queue implementation using nodes & links\n* O(1) constant time operations\n***/\n\nimport java.util.NoSuchElementException;\nimport java.util.Iterator;\n\npublic class Queue<E> implements Iterable<E> {\n\n  private class Node {\n    E data;\n    Node next;\n    public Node(final E data) {\n      this.data = data;\n    }\n  }\n\n  private int size;\n  private Node head; // Front of queue\n  private Node tail; // Rear of queue\n\n  public int size() {\n    return this.size;\n  }\n\n  public boolean isEmpty() {\n    return head == null;\n  }\n\n  public void enqueue(final E data) {\n    if (data == null) {\n      throw new NullPointerException(\"Null elements not permitted\");\n    }\n    if (this.isEmpty()) {\n      this.tail = new Node(data);\n      this.head = this.tail;\n    } else {\n      this.tail.next = new Node(data);\n      this.tail = this.tail.next;\n    }\n    this.size++;\n  }\n\n  public E dequeue() {\n    if (this.isEmpty()) {\n      return null; // Error\n    }\n    final E data = this.head.data;\n    this.head = this.head.next;\n    this.size--;\n    return data;\n  }\n\n  public E peek() {\n    if (this.isEmpty()) {\n      return null; // Error\n    }\n    return this.head.data;\n  }\n\n  public Iterator<E> iterator() {\n    return new QueueIterator();\n  }\n\n  private class QueueIterator implements Iterator<E> {\n\n    private Node current;\n\n    public QueueIterator() {\n      this.current = head;\n    }\n\n    @Override\n    public boolean hasNext() {\n      return this.current != null;\n    }\n\n    @Override\n    public E next() {\n      if (this.hasNext()) {\n        final E data = this.current.data;\n        this.current = this.current.next;\n        return data;\n      }\n      throw new NoSuchElementException(\"No more items in queue!\");\n    }\n\n    @Override\n    public void remove() {\n      /* Modification of a list during iteration is not recommended. */\n      throw new UnsupportedOperationException(\"remove() is not supported by this API\");\n    }\n  }\n\n  @Override\n  public String toString() {\n    if (this.isEmpty()) {\n      return \"REAR[ ]FRONT\";\n    }\n    StringBuilder builder = new StringBuilder(\"REAR[\");\n    for (Node current = head; current != null; current = current.next) {\n      builder.append(current.data + (current.next == null ? \"]FRONT\" : \", \"));\n    }\n    return builder.toString();\n  }\n\n}\n","markerStore":{"nextMarkerId":1,"markersById":{"0":{"range":{"start":{"row":109,"column":0},"end":{"row":109,"column":0}},"properties":{"type":"selection","editorId":16,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}},"version":2},"history":{"version":3,"nextCheckpointId":4,"undoStack":[{"type":"group-start","snapshot":{"0":{"range":[[0,0],[0,0]],"properties":{"type":"selection","editorId":16},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}}},{"type":"change","content":{"oldRange":[[0,0],[0,0]],"newRange":[[0,0],[109,0]],"oldText":"","newText":"/***\n* @author Varun Maudgalya\n* Queue implementation using nodes & links\n* O(1) constant time operations\n***/\n\nimport java.util.NoSuchElementException;\nimport java.util.Iterator;\n\npublic class Queue<E> implements Iterable<E> {\n\n  private class Node {\n    E data;\n    Node next;\n    public Node(final E data) {\n      this.data = data;\n    }\n  }\n\n  private int size;\n  private Node head; // Front of queue\n  private Node tail; // Rear of queue\n\n  public int size() {\n    return this.size;\n  }\n\n  public boolean isEmpty() {\n    return head == null;\n  }\n\n  public void enqueue(final E data) {\n    if (data == null) {\n      throw new NullPointerException(\"Null elements not permitted\");\n    }\n    if (this.isEmpty()) {\n      this.tail = new Node(data);\n      this.head = this.tail;\n    } else {\n      this.tail.next = new Node(data);\n      this.tail = this.tail.next;\n    }\n    this.size++;\n  }\n\n  public E dequeue() {\n    if (this.isEmpty()) {\n      return null; // Error\n    }\n    final E data = this.head.data;\n    this.head = this.head.next;\n    this.size--;\n    return data;\n  }\n\n  public E peek() {\n    if (this.isEmpty()) {\n      return null; // Error\n    }\n    return this.head.data;\n  }\n\n  public Iterator<E> iterator() {\n    return new QueueIterator();\n  }\n\n  private class QueueIterator implements Iterator<E> {\n\n    private Node current;\n\n    public QueueIterator() {\n      this.current = head;\n    }\n\n    @Override\n    public boolean hasNext() {\n      return this.current != null;\n    }\n\n    @Override\n    public E next() {\n      if (this.hasNext()) {\n        final E data = this.current.data;\n        this.current = this.current.next;\n        return data;\n      }\n      throw new NoSuchElementException(\"No more items in queue!\");\n    }\n\n    @Override\n    public void remove() {\n      /* Modification of a list during iteration is not recommended. */\n      throw new UnsupportedOperationException(\"remove() is not supported by this API\");\n    }\n  }\n\n  @Override\n  public String toString() {\n    if (this.isEmpty()) {\n      return \"REAR[ ]FRONT\";\n    }\n    StringBuilder builder = new StringBuilder(\"REAR[\");\n    for (Node current = head; current != null; current = current.next) {\n      builder.append(current.data + (current.next == null ? \"]FRONT\" : \", \"));\n    }\n    return builder.toString();\n  }\n\n}\n"}},{"type":"change","content":{"oldRange":[[0,0],[0,0]],"newRange":[[0,0],[0,0]],"oldText":"","newText":""}},{"type":"group-end","snapshot":{"0":{"range":[[109,0],[109,0]],"properties":{"type":"selection","editorId":16,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}}}],"redoStack":[]},"encoding":"utf8","filePath":"/Users/vmaudgalya/projects/personal/library/data_structures/Queue.java","digestWhenLastPersisted":"f90001c317f2d1ab5112e02eb5a4e0a635196667","preferredLineEnding":"\n","deserializer":"TextBuffer","version":2},{"text":"/*\n** @author Varun Maudgalya\n** @brief Singly Linked List Implementation\n** @date 11/14/2015\n*/\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\n\npublic class LinkedList<E extends Comparable<E>> implements Iterable<E> {\n\n  private class Node {\n    E data;\n    Node next; // Getters/setters not specified as this class is internal, and to reduce code bulk\n    public Node(E data) {\n      this.data = data;\n    }\n  }\n\n  private Node head;\n  private int size;\n\n  public int size() {\n    return this.size;\n  }\n\n  public boolean isEmpty() {\n    return this.head == null;\n  }\n\n  public boolean contains(final E data) {\n    if (this.isEmpty() || data == null) {\n      return false;\n    }\n    Node current = this.head;\n    while (current != null) {\n      if (data.compareTo(current.data) == 0) {\n        return true;\n      }\n      current = current.next;\n    }\n    return false;\n  }\n\n  private Node getLast(Node current) {\n    if (current == null) {\n      return null;\n    }\n    while (current.next != null) {\n      current = current.next;\n    }\n    return current;\n  }\n\n  public void addLast(final E data) {\n    if (data == null) {\n      return;\n    }\n    if (this.isEmpty()) {\n      this.head = new Node(data);\n    } else {\n      Node current = this.getLast(this.head);\n      current.next = new Node(data);\n    }\n    this.size++;\n  }\n\n  public E remove(final E data) {\n    if (this.isEmpty() || data == null) {\n      return null;\n    }\n    Node current = this.head;\n    if (data.compareTo(current.data) == 0) {\n      this.head = this.head.next;\n      this.size--;\n      return data;\n    }\n    while (current != null) {\n      if (data.compareTo(current.next.data) == 0) {\n        current.next = current.next.next;\n        this.size--;\n        return data;\n      }\n      current = current.next;\n    }\n    return null;\n  }\n\n  public Iterator<E> iterator() {\n    return new ListIterator();\n  }\n\n  private class ListIterator implements Iterator<E> {\n\n    private Node current;\n\n    public ListIterator() {\n      this.current = head;\n    }\n\n    @Override\n    public boolean hasNext() {\n      return this.current != null;\n    }\n\n    @Override\n    public E next() {\n      if (this.current == null) {\n        throw new NoSuchElementException(\"Error: No more elements to iterate over\");\n      }\n      E data = this.current.data;\n      this.current = this.current.next;\n      return data;\n    }\n\n    @Override\n    public void remove() {\n      /* Modification of a list during iteration is not recommended. */\n      throw new UnsupportedOperationException(\"remove() is not supported by this API\");\n    }\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder builder = new StringBuilder(\"[\");\n    Node current = this.head;\n    while (current != null) {\n      builder.append( (current.next == null) ? current.data : current.data + \", \");\n      current = current.next;\n    }\n    builder.append(\"]\");\n    return builder.toString();\n  }\n\n}\n","markerStore":{"nextMarkerId":5,"markersById":{"0":{"range":{"start":{"row":43,"column":15},"end":{"row":43,"column":22}},"properties":{"type":"selection","editorId":20,"goalScreenRange":null,"autoscroll":false},"reversed":false,"tailed":true,"valid":true,"invalidate":"never","maintainHistory":true},"1":{"range":{"start":{"row":43,"column":15},"end":{"row":43,"column":22}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":false},"2":{"range":{"start":{"row":60,"column":26},"end":{"row":60,"column":33}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":false},"3":{"range":{"start":{"row":43,"column":15},"end":{"row":43,"column":22}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":false},"4":{"range":{"start":{"row":60,"column":26},"end":{"row":60,"column":33}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":false}},"version":2},"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/vmaudgalya/projects/personal/library/data_structures/LinkedList.java","digestWhenLastPersisted":"d7a95d16d638ded25f625078c93ba9590e07945a","preferredLineEnding":null,"deserializer":"TextBuffer","version":2}]},"workspace":{"deserializer":"Workspace","paneContainer":{"deserializer":"PaneContainer","version":1,"root":{"deserializer":"Pane","id":3,"items":[{"deserializer":"TextEditor","id":8,"softTabs":true,"scrollRow":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":9,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/vmaudgalya/projects/personal/library/data_structures/Stack.java","largeFileMode":false},"largeFileMode":false}},{"deserializer":"TextEditor","id":20,"softTabs":true,"scrollRow":6,"displayBuffer":{"deserializer":"DisplayBuffer","id":21,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/vmaudgalya/projects/personal/library/data_structures/LinkedList.java","largeFileMode":false},"largeFileMode":false}},{"deserializer":"TextEditor","id":16,"softTabs":true,"scrollRow":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":17,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/vmaudgalya/projects/personal/library/data_structures/Queue.java","largeFileMode":false},"largeFileMode":false}}],"activeItemURI":"/Users/vmaudgalya/projects/personal/library/data_structures/LinkedList.java","focused":true,"flexScale":1},"activePaneId":3},"packagesWithActiveGrammars":["language-java","language-hyperlink","language-todo"],"destroyedItemURIs":[]},"packageStates":{"linter":{"scope":"File"},"pigments":{"project":{"deserializer":"ColorProject","timestamp":"2015-12-01T21:58:51.093Z","version":"1.0.1","markersVersion":"1.0.5","globalSourceNames":["**/*.styl","**/*.stylus","**/*.less","**/*.sass","**/*.scss"],"globalIgnoredNames":["vendor/*","node_modules/*","spec/*","test/*"],"buffers":{"8":{"id":8,"path":"/Users/vmaudgalya/projects/personal/library/data_structures/Stack.java","colorMarkers":[]},"16":{"id":16,"path":"/Users/vmaudgalya/projects/personal/library/data_structures/Queue.java","colorMarkers":[]},"20":{"id":20,"path":"/Users/vmaudgalya/projects/personal/library/data_structures/LinkedList.java","colorMarkers":[]}},"paths":[],"variables":{"deserializer":"VariablesCollection","content":[]}}},"fuzzy-finder":{"/Users/vmaudgalya/projects/personal/library/data_structures/Stack.java":1448950687828,"/Users/vmaudgalya/projects/personal/library/data_structures/LinkedList.java":1448950698301,"/Users/vmaudgalya/projects/personal/library/data_structures/Queue.java":1448950678950},"metrics":{"sessionLength":56459376},"tabs":[{}],"tree-view":{"directoryExpansionStates":{"/Users/vmaudgalya/projects/personal/library":{"isExpanded":true,"entries":{".git":{"isExpanded":false,"entries":{}},"data_structures":{"isExpanded":true,"entries":{}}}}},"selectedPath":"/Users/vmaudgalya/projects/personal/library/data_structures/LinkedList.java","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}},"fullScreen":false}